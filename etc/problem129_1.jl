
# We're going to try to break this down inductively.

import Primes

inverses = Dict(
    1 => 1,
    3 => 7,
    7 => 3,
    9 => 9,
)
divide(a, b) = (inverses[b] * a) % 10

struct PrimeFactor{T}
    factor::T
    count::Int64
end

function primefactors(n)
    result = []
    i = 2
    while n != 1
        count = 0
        while n % i == 0
            count += 1
            n = div(n, i)
        end
        if count > 0
            push!(result, PrimeFactor(i, count))
        end
        i += 1
    end
    result
end

function a(n)
    left = 1
    count = 0
    acc = 10
    while left != 0
        multiplicand = divide(left, n % 10)
        subtrahend = multiplicand * n
        left -= subtrahend
        left = div(left, 10)
        acc = div(acc, 10)
        # If we get a negative number during calculation, we need to
        # "correct" it by adding ones to the left, as many as
        # necessary.
        while left < 0
            left += acc
            acc *= 10
            count += 1
        end
    end
    count + 1
end

_memo = Dict()
function memoa(n)
    if !(n in keys(_memo))
        _memo[n] = a(n)
    end
    _memo[n]
end

# Based on observed sequence which seems to be OEIS A006556
function primea(p)

    # 3 is a silly corner case so it gets to sit in the silly corner :)
    if p == 3
        return 3
    end

    acc = 10 % p
    x = 1
    while acc != 1
        acc = (acc * 10) % p
        x += 1
    end
    x
end

# I have no earthly clue why this formula works. I figured it out by
# experimenting with the table generated by the brute-force a(...)
# function above and it shockingly seems to hold up.
function opta(n)
    factors = primefactors(n)
    reduce(lcm, map((x) -> primea(x.factor) * x.factor ^ (x.count - 1), factors))
end

r(k) = k == 1 ? convert(typeof(k), 1) : 10 * r(k - 1) + 1

function solve()
    # Last digit is necessarily 1, 3, 7, 9. This is necessary and
    # sufficient for gcd(n + d, 10) == 1.
    lastdigit = [1 3 7 9]
    for n = Iterators.countfrom(10, 10), d = lastdigit
        if opta(n + d) > 1000000
            println(n + d)
            break
        end
    end
end

solve()

# Note: We also have the beautiful property that a(n) <= n
