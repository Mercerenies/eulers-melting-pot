/* problem93.c generated by valac 0.40.23, the Vala compiler
 * generated from problem93.gs, do not modify */



#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>


#define TYPE_BINARY_OP (binary_op_get_type ())
#define BINARY_OP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BINARY_OP, BinaryOp))
#define IS_BINARY_OP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BINARY_OP))
#define BINARY_OP_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_BINARY_OP, BinaryOpIface))

typedef struct _BinaryOp BinaryOp;
typedef struct _BinaryOpIface BinaryOpIface;

#define TYPE_ADD (add_get_type ())
#define ADD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ADD, Add))
#define ADD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ADD, AddClass))
#define IS_ADD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ADD))
#define IS_ADD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ADD))
#define ADD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ADD, AddClass))

typedef struct _Add Add;
typedef struct _AddClass AddClass;
typedef struct _AddPrivate AddPrivate;
enum  {
	ADD_0_PROPERTY,
	ADD_NUM_PROPERTIES
};
static GParamSpec* add_properties[ADD_NUM_PROPERTIES];

#define TYPE_SUB (sub_get_type ())
#define SUB(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SUB, Sub))
#define SUB_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SUB, SubClass))
#define IS_SUB(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SUB))
#define IS_SUB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SUB))
#define SUB_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SUB, SubClass))

typedef struct _Sub Sub;
typedef struct _SubClass SubClass;
typedef struct _SubPrivate SubPrivate;
enum  {
	SUB_0_PROPERTY,
	SUB_NUM_PROPERTIES
};
static GParamSpec* sub_properties[SUB_NUM_PROPERTIES];

#define TYPE_MUL (mul_get_type ())
#define MUL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MUL, Mul))
#define MUL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MUL, MulClass))
#define IS_MUL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MUL))
#define IS_MUL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MUL))
#define MUL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MUL, MulClass))

typedef struct _Mul Mul;
typedef struct _MulClass MulClass;
typedef struct _MulPrivate MulPrivate;
enum  {
	MUL_0_PROPERTY,
	MUL_NUM_PROPERTIES
};
static GParamSpec* mul_properties[MUL_NUM_PROPERTIES];

#define TYPE_DIV (div_get_type ())
#define DIV(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DIV, Div))
#define DIV_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DIV, DivClass))
#define IS_DIV(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DIV))
#define IS_DIV_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DIV))
#define DIV_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DIV, DivClass))

typedef struct _Div Div;
typedef struct _DivClass DivClass;
typedef struct _DivPrivate DivPrivate;
enum  {
	DIV_0_PROPERTY,
	DIV_NUM_PROPERTIES
};
static GParamSpec* div_properties[DIV_NUM_PROPERTIES];

#define TYPE_TREE_NODE (tree_node_get_type ())
#define TREE_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TREE_NODE, TreeNode))
#define IS_TREE_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TREE_NODE))
#define TREE_NODE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_TREE_NODE, TreeNodeIface))

typedef struct _TreeNode TreeNode;
typedef struct _TreeNodeIface TreeNodeIface;

#define TYPE_LEAF_NODE (leaf_node_get_type ())
#define LEAF_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LEAF_NODE, LeafNode))
#define LEAF_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LEAF_NODE, LeafNodeClass))
#define IS_LEAF_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LEAF_NODE))
#define IS_LEAF_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LEAF_NODE))
#define LEAF_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LEAF_NODE, LeafNodeClass))

typedef struct _LeafNode LeafNode;
typedef struct _LeafNodeClass LeafNodeClass;
typedef struct _LeafNodePrivate LeafNodePrivate;
enum  {
	LEAF_NODE_0_PROPERTY,
	LEAF_NODE_NUM_PROPERTIES
};
static GParamSpec* leaf_node_properties[LEAF_NODE_NUM_PROPERTIES];

#define TYPE_BRANCH_NODE (branch_node_get_type ())
#define BRANCH_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BRANCH_NODE, BranchNode))
#define BRANCH_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BRANCH_NODE, BranchNodeClass))
#define IS_BRANCH_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BRANCH_NODE))
#define IS_BRANCH_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BRANCH_NODE))
#define BRANCH_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BRANCH_NODE, BranchNodeClass))

typedef struct _BranchNode BranchNode;
typedef struct _BranchNodeClass BranchNodeClass;
typedef struct _BranchNodePrivate BranchNodePrivate;
enum  {
	BRANCH_NODE_0_PROPERTY,
	BRANCH_NODE_NUM_PROPERTIES
};
static GParamSpec* branch_node_properties[BRANCH_NODE_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_ptr_array_unref0(var) ((var == NULL) ? NULL : (var = (g_ptr_array_unref (var), NULL)))

struct _BinaryOpIface {
	GTypeInterface parent_iface;
	gfloat (*apply) (BinaryOp* self, gfloat a, gfloat b);
};

struct _Add {
	GObject parent_instance;
	AddPrivate * priv;
};

struct _AddClass {
	GObjectClass parent_class;
};

struct _Sub {
	GObject parent_instance;
	SubPrivate * priv;
};

struct _SubClass {
	GObjectClass parent_class;
};

struct _Mul {
	GObject parent_instance;
	MulPrivate * priv;
};

struct _MulClass {
	GObjectClass parent_class;
};

struct _Div {
	GObject parent_instance;
	DivPrivate * priv;
};

struct _DivClass {
	GObjectClass parent_class;
};

struct _TreeNodeIface {
	GTypeInterface parent_iface;
	gfloat (*apply) (TreeNode* self, GPtrArray* args, gint index);
	gint (*getWeight) (TreeNode* self);
};

struct _LeafNode {
	GObject parent_instance;
	LeafNodePrivate * priv;
};

struct _LeafNodeClass {
	GObjectClass parent_class;
};

struct _BranchNode {
	GObject parent_instance;
	BranchNodePrivate * priv;
	TreeNode* left;
	TreeNode* right;
	BinaryOp* op;
};

struct _BranchNodeClass {
	GObjectClass parent_class;
};


static gpointer add_parent_class = NULL;
static BinaryOpIface * add_binary_op_parent_iface = NULL;
static gpointer sub_parent_class = NULL;
static BinaryOpIface * sub_binary_op_parent_iface = NULL;
static gpointer mul_parent_class = NULL;
static BinaryOpIface * mul_binary_op_parent_iface = NULL;
static gpointer div_parent_class = NULL;
static BinaryOpIface * div_binary_op_parent_iface = NULL;
static gpointer leaf_node_parent_class = NULL;
static TreeNodeIface * leaf_node_tree_node_parent_iface = NULL;
static gpointer branch_node_parent_class = NULL;
static TreeNodeIface * branch_node_tree_node_parent_iface = NULL;

void _vala_main (gchar** args,
                 int args_length1);
GType binary_op_get_type (void) G_GNUC_CONST;
gfloat binary_op_apply (BinaryOp* self,
                        gfloat a,
                        gfloat b);
GType add_get_type (void) G_GNUC_CONST;
static gfloat add_real_apply (BinaryOp* base,
                       gfloat a,
                       gfloat b);
Add* add_new (void);
Add* add_construct (GType object_type);
GType sub_get_type (void) G_GNUC_CONST;
static gfloat sub_real_apply (BinaryOp* base,
                       gfloat a,
                       gfloat b);
Sub* sub_new (void);
Sub* sub_construct (GType object_type);
GType mul_get_type (void) G_GNUC_CONST;
static gfloat mul_real_apply (BinaryOp* base,
                       gfloat a,
                       gfloat b);
Mul* mul_new (void);
Mul* mul_construct (GType object_type);
GType div_get_type (void) G_GNUC_CONST;
static gfloat div_real_apply (BinaryOp* base,
                       gfloat a,
                       gfloat b);
Div* div_new (void);
Div* div_construct (GType object_type);
GType tree_node_get_type (void) G_GNUC_CONST;
gfloat tree_node_apply (TreeNode* self,
                        GPtrArray* args,
                        gint index);
gint tree_node_getWeight (TreeNode* self);
GType leaf_node_get_type (void) G_GNUC_CONST;
static gfloat leaf_node_real_apply (TreeNode* base,
                             GPtrArray* args,
                             gint index);
static gint leaf_node_real_getWeight (TreeNode* base);
LeafNode* leaf_node_new (void);
LeafNode* leaf_node_construct (GType object_type);
GType branch_node_get_type (void) G_GNUC_CONST;
BranchNode* branch_node_new (TreeNode* left_,
                             TreeNode* right_,
                             BinaryOp* op_);
BranchNode* branch_node_construct (GType object_type,
                                   TreeNode* left_,
                                   TreeNode* right_,
                                   BinaryOp* op_);
static gint branch_node_real_getWeight (TreeNode* base);
static gfloat branch_node_real_apply (TreeNode* base,
                               GPtrArray* args,
                               gint index);
static void branch_node_finalize (GObject * obj);
void allTrees (gint n,
               GPtrArray* arr);
static void _g_object_unref0_ (gpointer var);


void
_vala_main (gchar** args,
            int args_length1)
{
	g_print ("Hello World\n");
}


int
main (int argc,
      char ** argv)
{
	_vala_main (argv, argc);
	return 0;
}


gfloat
binary_op_apply (BinaryOp* self,
                 gfloat a,
                 gfloat b)
{
	g_return_val_if_fail (self != NULL, 0.0F);
	return BINARY_OP_GET_INTERFACE (self)->apply (self, a, b);
}


static void
binary_op_default_init (BinaryOpIface * iface)
{
}


GType
binary_op_get_type (void)
{
	static volatile gsize binary_op_type_id__volatile = 0;
	if (g_once_init_enter (&binary_op_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (BinaryOpIface), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) binary_op_default_init, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType binary_op_type_id;
		binary_op_type_id = g_type_register_static (G_TYPE_INTERFACE, "BinaryOp", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (binary_op_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&binary_op_type_id__volatile, binary_op_type_id);
	}
	return binary_op_type_id__volatile;
}


static gfloat
add_real_apply (BinaryOp* base,
                gfloat a,
                gfloat b)
{
	Add * self;
	gfloat result = 0.0F;
	self = (Add*) base;
	result = a + b;
	return result;
}


Add*
add_construct (GType object_type)
{
	Add * self = NULL;
	self = (Add*) g_object_new (object_type, NULL);
	return self;
}


Add*
add_new (void)
{
	return add_construct (TYPE_ADD);
}


static void
add_class_init (AddClass * klass)
{
	add_parent_class = g_type_class_peek_parent (klass);
}


static void
add_binary_op_interface_init (BinaryOpIface * iface)
{
	add_binary_op_parent_iface = g_type_interface_peek_parent (iface);
	iface->apply = (gfloat (*) (BinaryOp*, gfloat, gfloat)) add_real_apply;
}


static void
add_instance_init (Add * self)
{
}


GType
add_get_type (void)
{
	static volatile gsize add_type_id__volatile = 0;
	if (g_once_init_enter (&add_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AddClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) add_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Add), 0, (GInstanceInitFunc) add_instance_init, NULL };
		static const GInterfaceInfo binary_op_info = { (GInterfaceInitFunc) add_binary_op_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType add_type_id;
		add_type_id = g_type_register_static (G_TYPE_OBJECT, "Add", &g_define_type_info, 0);
		g_type_add_interface_static (add_type_id, TYPE_BINARY_OP, &binary_op_info);
		g_once_init_leave (&add_type_id__volatile, add_type_id);
	}
	return add_type_id__volatile;
}


static gfloat
sub_real_apply (BinaryOp* base,
                gfloat a,
                gfloat b)
{
	Sub * self;
	gfloat result = 0.0F;
	self = (Sub*) base;
	result = a - b;
	return result;
}


Sub*
sub_construct (GType object_type)
{
	Sub * self = NULL;
	self = (Sub*) g_object_new (object_type, NULL);
	return self;
}


Sub*
sub_new (void)
{
	return sub_construct (TYPE_SUB);
}


static void
sub_class_init (SubClass * klass)
{
	sub_parent_class = g_type_class_peek_parent (klass);
}


static void
sub_binary_op_interface_init (BinaryOpIface * iface)
{
	sub_binary_op_parent_iface = g_type_interface_peek_parent (iface);
	iface->apply = (gfloat (*) (BinaryOp*, gfloat, gfloat)) sub_real_apply;
}


static void
sub_instance_init (Sub * self)
{
}


GType
sub_get_type (void)
{
	static volatile gsize sub_type_id__volatile = 0;
	if (g_once_init_enter (&sub_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SubClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) sub_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Sub), 0, (GInstanceInitFunc) sub_instance_init, NULL };
		static const GInterfaceInfo binary_op_info = { (GInterfaceInitFunc) sub_binary_op_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType sub_type_id;
		sub_type_id = g_type_register_static (G_TYPE_OBJECT, "Sub", &g_define_type_info, 0);
		g_type_add_interface_static (sub_type_id, TYPE_BINARY_OP, &binary_op_info);
		g_once_init_leave (&sub_type_id__volatile, sub_type_id);
	}
	return sub_type_id__volatile;
}


static gfloat
mul_real_apply (BinaryOp* base,
                gfloat a,
                gfloat b)
{
	Mul * self;
	gfloat result = 0.0F;
	self = (Mul*) base;
	result = a * b;
	return result;
}


Mul*
mul_construct (GType object_type)
{
	Mul * self = NULL;
	self = (Mul*) g_object_new (object_type, NULL);
	return self;
}


Mul*
mul_new (void)
{
	return mul_construct (TYPE_MUL);
}


static void
mul_class_init (MulClass * klass)
{
	mul_parent_class = g_type_class_peek_parent (klass);
}


static void
mul_binary_op_interface_init (BinaryOpIface * iface)
{
	mul_binary_op_parent_iface = g_type_interface_peek_parent (iface);
	iface->apply = (gfloat (*) (BinaryOp*, gfloat, gfloat)) mul_real_apply;
}


static void
mul_instance_init (Mul * self)
{
}


GType
mul_get_type (void)
{
	static volatile gsize mul_type_id__volatile = 0;
	if (g_once_init_enter (&mul_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MulClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) mul_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Mul), 0, (GInstanceInitFunc) mul_instance_init, NULL };
		static const GInterfaceInfo binary_op_info = { (GInterfaceInitFunc) mul_binary_op_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType mul_type_id;
		mul_type_id = g_type_register_static (G_TYPE_OBJECT, "Mul", &g_define_type_info, 0);
		g_type_add_interface_static (mul_type_id, TYPE_BINARY_OP, &binary_op_info);
		g_once_init_leave (&mul_type_id__volatile, mul_type_id);
	}
	return mul_type_id__volatile;
}


static gfloat
div_real_apply (BinaryOp* base,
                gfloat a,
                gfloat b)
{
	Div * self;
	gfloat result = 0.0F;
	self = (Div*) base;
	result = a / b;
	return result;
}


Div*
div_construct (GType object_type)
{
	Div * self = NULL;
	self = (Div*) g_object_new (object_type, NULL);
	return self;
}


Div*
div_new (void)
{
	return div_construct (TYPE_DIV);
}


static void
div_class_init (DivClass * klass)
{
	div_parent_class = g_type_class_peek_parent (klass);
}


static void
div_binary_op_interface_init (BinaryOpIface * iface)
{
	div_binary_op_parent_iface = g_type_interface_peek_parent (iface);
	iface->apply = (gfloat (*) (BinaryOp*, gfloat, gfloat)) div_real_apply;
}


static void
div_instance_init (Div * self)
{
}


GType
div_get_type (void)
{
	static volatile gsize div_type_id__volatile = 0;
	if (g_once_init_enter (&div_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DivClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) div_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Div), 0, (GInstanceInitFunc) div_instance_init, NULL };
		static const GInterfaceInfo binary_op_info = { (GInterfaceInitFunc) div_binary_op_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType div_type_id;
		div_type_id = g_type_register_static (G_TYPE_OBJECT, "Div", &g_define_type_info, 0);
		g_type_add_interface_static (div_type_id, TYPE_BINARY_OP, &binary_op_info);
		g_once_init_leave (&div_type_id__volatile, div_type_id);
	}
	return div_type_id__volatile;
}


gfloat
tree_node_apply (TreeNode* self,
                 GPtrArray* args,
                 gint index)
{
	g_return_val_if_fail (self != NULL, 0.0F);
	return TREE_NODE_GET_INTERFACE (self)->apply (self, args, index);
}


gint
tree_node_getWeight (TreeNode* self)
{
	g_return_val_if_fail (self != NULL, 0);
	return TREE_NODE_GET_INTERFACE (self)->getWeight (self);
}


static void
tree_node_default_init (TreeNodeIface * iface)
{
}


GType
tree_node_get_type (void)
{
	static volatile gsize tree_node_type_id__volatile = 0;
	if (g_once_init_enter (&tree_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (TreeNodeIface), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) tree_node_default_init, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType tree_node_type_id;
		tree_node_type_id = g_type_register_static (G_TYPE_INTERFACE, "TreeNode", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (tree_node_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&tree_node_type_id__volatile, tree_node_type_id);
	}
	return tree_node_type_id__volatile;
}


static gfloat
leaf_node_real_apply (TreeNode* base,
                      GPtrArray* args,
                      gint index)
{
	LeafNode * self;
	gfloat result = 0.0F;
	gconstpointer _tmp0_;
	self = (LeafNode*) base;
	g_return_val_if_fail (args != NULL, 0.0F);
	_tmp0_ = g_ptr_array_index (args, (guint) index);
	result = *((gfloat*) _tmp0_);
	return result;
}


static gint
leaf_node_real_getWeight (TreeNode* base)
{
	LeafNode * self;
	gint result = 0;
	self = (LeafNode*) base;
	result = 1;
	return result;
}


LeafNode*
leaf_node_construct (GType object_type)
{
	LeafNode * self = NULL;
	self = (LeafNode*) g_object_new (object_type, NULL);
	return self;
}


LeafNode*
leaf_node_new (void)
{
	return leaf_node_construct (TYPE_LEAF_NODE);
}


static void
leaf_node_class_init (LeafNodeClass * klass)
{
	leaf_node_parent_class = g_type_class_peek_parent (klass);
}


static void
leaf_node_tree_node_interface_init (TreeNodeIface * iface)
{
	leaf_node_tree_node_parent_iface = g_type_interface_peek_parent (iface);
	iface->apply = (gfloat (*) (TreeNode*, GPtrArray*, gint)) leaf_node_real_apply;
	iface->getWeight = (gint (*) (TreeNode*)) leaf_node_real_getWeight;
}


static void
leaf_node_instance_init (LeafNode * self)
{
}


GType
leaf_node_get_type (void)
{
	static volatile gsize leaf_node_type_id__volatile = 0;
	if (g_once_init_enter (&leaf_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (LeafNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) leaf_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (LeafNode), 0, (GInstanceInitFunc) leaf_node_instance_init, NULL };
		static const GInterfaceInfo tree_node_info = { (GInterfaceInitFunc) leaf_node_tree_node_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType leaf_node_type_id;
		leaf_node_type_id = g_type_register_static (G_TYPE_OBJECT, "LeafNode", &g_define_type_info, 0);
		g_type_add_interface_static (leaf_node_type_id, TYPE_TREE_NODE, &tree_node_info);
		g_once_init_leave (&leaf_node_type_id__volatile, leaf_node_type_id);
	}
	return leaf_node_type_id__volatile;
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


BranchNode*
branch_node_construct (GType object_type,
                       TreeNode* left_,
                       TreeNode* right_,
                       BinaryOp* op_)
{
	BranchNode * self = NULL;
	TreeNode* _tmp0_;
	TreeNode* _tmp1_;
	BinaryOp* _tmp2_;
	g_return_val_if_fail (left_ != NULL, NULL);
	g_return_val_if_fail (right_ != NULL, NULL);
	g_return_val_if_fail (op_ != NULL, NULL);
	self = (BranchNode*) g_object_new (object_type, NULL);
	_tmp0_ = _g_object_ref0 (left_);
	_g_object_unref0 (self->left);
	self->left = _tmp0_;
	_tmp1_ = _g_object_ref0 (right_);
	_g_object_unref0 (self->right);
	self->right = _tmp1_;
	_tmp2_ = _g_object_ref0 (op_);
	_g_object_unref0 (self->op);
	self->op = _tmp2_;
	return self;
}


BranchNode*
branch_node_new (TreeNode* left_,
                 TreeNode* right_,
                 BinaryOp* op_)
{
	return branch_node_construct (TYPE_BRANCH_NODE, left_, right_, op_);
}


static gint
branch_node_real_getWeight (TreeNode* base)
{
	BranchNode * self;
	gint result = 0;
	TreeNode* _tmp0_;
	TreeNode* _tmp1_;
	self = (BranchNode*) base;
	_tmp0_ = self->left;
	_tmp1_ = self->right;
	result = tree_node_getWeight (_tmp0_) + tree_node_getWeight (_tmp1_);
	return result;
}


static gfloat
branch_node_real_apply (TreeNode* base,
                        GPtrArray* args,
                        gint index)
{
	BranchNode * self;
	gfloat result = 0.0F;
	gint pivot = 0;
	TreeNode* _tmp0_;
	gfloat lhs = 0.0F;
	TreeNode* _tmp1_;
	gfloat rhs = 0.0F;
	TreeNode* _tmp2_;
	BinaryOp* _tmp3_;
	self = (BranchNode*) base;
	g_return_val_if_fail (args != NULL, 0.0F);
	_tmp0_ = self->left;
	pivot = index + tree_node_getWeight (_tmp0_);
	_tmp1_ = self->left;
	lhs = tree_node_apply (_tmp1_, args, index);
	_tmp2_ = self->right;
	rhs = tree_node_apply (_tmp2_, args, pivot);
	_tmp3_ = self->op;
	result = binary_op_apply (_tmp3_, lhs, rhs);
	return result;
}


static void
branch_node_class_init (BranchNodeClass * klass)
{
	branch_node_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = branch_node_finalize;
}


static void
branch_node_tree_node_interface_init (TreeNodeIface * iface)
{
	branch_node_tree_node_parent_iface = g_type_interface_peek_parent (iface);
	iface->getWeight = (gint (*) (TreeNode*)) branch_node_real_getWeight;
	iface->apply = (gfloat (*) (TreeNode*, GPtrArray*, gint)) branch_node_real_apply;
}


static void
branch_node_instance_init (BranchNode * self)
{
}


static void
branch_node_finalize (GObject * obj)
{
	BranchNode * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_BRANCH_NODE, BranchNode);
	_g_object_unref0 (self->left);
	_g_object_unref0 (self->right);
	_g_object_unref0 (self->op);
	G_OBJECT_CLASS (branch_node_parent_class)->finalize (obj);
}


GType
branch_node_get_type (void)
{
	static volatile gsize branch_node_type_id__volatile = 0;
	if (g_once_init_enter (&branch_node_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (BranchNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) branch_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BranchNode), 0, (GInstanceInitFunc) branch_node_instance_init, NULL };
		static const GInterfaceInfo tree_node_info = { (GInterfaceInitFunc) branch_node_tree_node_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType branch_node_type_id;
		branch_node_type_id = g_type_register_static (G_TYPE_OBJECT, "BranchNode", &g_define_type_info, 0);
		g_type_add_interface_static (branch_node_type_id, TYPE_TREE_NODE, &tree_node_info);
		g_once_init_leave (&branch_node_type_id__volatile, branch_node_type_id);
	}
	return branch_node_type_id__volatile;
}


static void
_g_object_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


void
allTrees (gint n,
          GPtrArray* arr)
{
	GPtrArray* ops = NULL;
	GPtrArray* _tmp0_;
	GPtrArray* _tmp1_;
	Add* _tmp2_;
	GPtrArray* _tmp3_;
	Sub* _tmp4_;
	GPtrArray* _tmp5_;
	Mul* _tmp6_;
	GPtrArray* _tmp7_;
	Div* _tmp8_;
	g_return_if_fail (arr != NULL);
	_tmp0_ = g_ptr_array_new_full ((guint) 0, _g_object_unref0_);
	ops = _tmp0_;
	_tmp1_ = ops;
	_tmp2_ = add_new ();
	g_ptr_array_add (_tmp1_, (BinaryOp*) _tmp2_);
	_tmp3_ = ops;
	_tmp4_ = sub_new ();
	g_ptr_array_add (_tmp3_, (BinaryOp*) _tmp4_);
	_tmp5_ = ops;
	_tmp6_ = mul_new ();
	g_ptr_array_add (_tmp5_, (BinaryOp*) _tmp6_);
	_tmp7_ = ops;
	_tmp8_ = div_new ();
	g_ptr_array_add (_tmp7_, (BinaryOp*) _tmp8_);
	if (n == 1) {
		LeafNode* _tmp9_;
		_tmp9_ = leaf_node_new ();
		g_ptr_array_add (arr, (TreeNode*) _tmp9_);
	} else {
		gint i = 0;
		i = 1;
		while (TRUE) {
			gint _tmp10_;
			gint j = 0;
			gint _tmp11_;
			GPtrArray* left = NULL;
			GPtrArray* _tmp12_;
			GPtrArray* right = NULL;
			GPtrArray* _tmp13_;
			gint _tmp14_;
			GPtrArray* _tmp15_;
			gint _tmp16_;
			GPtrArray* _tmp17_;
			GPtrArray* _tmp18_;
			gpointer* _tmp19_;
			gint _tmp19__length1;
			gint _tmp31_;
			_tmp10_ = i;
			if (!(_tmp10_ < n)) {
				break;
			}
			_tmp11_ = i;
			j = n - _tmp11_;
			_tmp12_ = g_ptr_array_new_full ((guint) 0, _g_object_unref0_);
			left = _tmp12_;
			_tmp13_ = g_ptr_array_new_full ((guint) 0, _g_object_unref0_);
			right = _tmp13_;
			_tmp14_ = i;
			_tmp15_ = left;
			allTrees (_tmp14_, _tmp15_);
			_tmp16_ = j;
			_tmp17_ = right;
			allTrees (_tmp16_, _tmp17_);
			_tmp18_ = left;
			_tmp19_ = _tmp18_->pdata;
			_tmp19__length1 = (gint) _tmp18_->len;
			{
				TreeNode** lhs_collection = NULL;
				gint lhs_collection_length1 = 0;
				gint _lhs_collection_size_ = 0;
				gint lhs_it = 0;
				lhs_collection = _tmp19_;
				lhs_collection_length1 = _tmp19__length1;
				for (lhs_it = 0; lhs_it < lhs_collection_length1; lhs_it = lhs_it + 1) {
					TreeNode* _tmp20_;
					TreeNode* lhs = NULL;
					_tmp20_ = _g_object_ref0 (lhs_collection[lhs_it]);
					lhs = _tmp20_;
					{
						GPtrArray* _tmp21_;
						gpointer* _tmp22_;
						gint _tmp22__length1;
						_tmp21_ = right;
						_tmp22_ = _tmp21_->pdata;
						_tmp22__length1 = (gint) _tmp21_->len;
						{
							TreeNode** rhs_collection = NULL;
							gint rhs_collection_length1 = 0;
							gint _rhs_collection_size_ = 0;
							gint rhs_it = 0;
							rhs_collection = _tmp22_;
							rhs_collection_length1 = _tmp22__length1;
							for (rhs_it = 0; rhs_it < rhs_collection_length1; rhs_it = rhs_it + 1) {
								TreeNode* _tmp23_;
								TreeNode* rhs = NULL;
								_tmp23_ = _g_object_ref0 (rhs_collection[rhs_it]);
								rhs = _tmp23_;
								{
									GPtrArray* _tmp24_;
									gpointer* _tmp25_;
									gint _tmp25__length1;
									_tmp24_ = ops;
									_tmp25_ = _tmp24_->pdata;
									_tmp25__length1 = (gint) _tmp24_->len;
									{
										BinaryOp** op_collection = NULL;
										gint op_collection_length1 = 0;
										gint _op_collection_size_ = 0;
										gint op_it = 0;
										op_collection = _tmp25_;
										op_collection_length1 = _tmp25__length1;
										for (op_it = 0; op_it < op_collection_length1; op_it = op_it + 1) {
											BinaryOp* _tmp26_;
											BinaryOp* op = NULL;
											_tmp26_ = _g_object_ref0 (op_collection[op_it]);
											op = _tmp26_;
											{
												TreeNode* _tmp27_;
												TreeNode* _tmp28_;
												BinaryOp* _tmp29_;
												BranchNode* _tmp30_;
												_tmp27_ = lhs;
												_tmp28_ = rhs;
												_tmp29_ = op;
												_tmp30_ = branch_node_new (_tmp27_, _tmp28_, _tmp29_);
												g_ptr_array_add (arr, (TreeNode*) _tmp30_);
												_g_object_unref0 (op);
											}
										}
									}
									_g_object_unref0 (rhs);
								}
							}
						}
						_g_object_unref0 (lhs);
					}
				}
			}
			_tmp31_ = i;
			i = _tmp31_ + 1;
			_g_ptr_array_unref0 (right);
			_g_ptr_array_unref0 (left);
		}
	}
	_g_ptr_array_unref0 (ops);
}



